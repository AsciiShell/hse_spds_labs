%!TEX TS-program = xelatex

% Шаблон документа LaTeX создан в 2018 году
% Алексеем Подчезерцевым
% В качестве исходных использованы шаблоны
% 	Данилом Фёдоровых (danil@fedorovykh.ru) 
%		https://www.writelatex.com/coursera/latex/5.2.2
%	LaTeX-шаблон для русской кандидатской диссертации и её автореферата.
%		https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template

\documentclass[a4paper,14pt]{article}

\input{data/preambular.tex}
\begin{document} % конец преамбулы, начало документа
	\input{data/title.tex}
	\tableofcontents
	\pagebreak
	\section{Задание}
	
	\begin{enumerate}
		\item Изучить разделы 6.2, 6.3, 6.4, 6.7 и приложение В книги H\&H.
		Добавить в микропроцессор в соответствии со своим вариантом	поддержку следующих команд: j, xori, sllv, nor.
		
		\item Разработать программу, продемонстрировать на модели и прототипе правильность их работы.
		Разработать в соответствии со своим вариантом программу, продемонстрировать на модели и прототипе правильность ее работы.
		Добавить ее в проект микропроцессора; добавить в папку с программой файл описания.
		Использовать только те команды, которые есть в процессоре.
		
		6) Найти сумму геометрической прогрессии (количество членов прогрессии = ваш
		вариант \% 30 + 3, знаменатель прогрессии = ваш вариант \% 10 + 1)
		
		\item Перейти в ветку проекта schoolMIPS 01\_mmio.
		Скачать новую версию процессора и выполнить на вашей плате (или DE10-Lite)
		программы 00\_counter, 01\_fibonacci, 02\_sqrt. Убедиться, что они работают также.
		Выполнить одну из программ (по вариантам):
		
		2) 04\_gpio
	\end{enumerate}

	%{\small \VerbatimInput{../03_syn_pow_5_single_cycle_always/pow_5_single_cycle_always.v}}
	
	\section{Выполнение работы}
	
	\subsection{Моделирование счетчика}
	
	Ассемблерный код счетчика представлен на листинге ниже.
	
	{\small \VerbatimInput{../program/00_counter/main.S}}
	
	Моделирование программы проводилось в среде Icarus Verilog.
	
	Ниже приведена часть логов из выполнения программы:
	
	{\small \VerbatimInput{./logs/00_counter.txt}}
	
	Вейвформа при моделировании программы (рис. \ref{fig:00wvf}).
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.95\linewidth]{images/00_wvf}
		\caption{Вейвформа для программы счетчика}
		\label{fig:00wvf}
	\end{figure}

	Можно заметить, что значение интересующего нас регистра постепенно увеличивается на 1, результат помещается в регистр v0.
	
	
	\subsection{Моделирование последовательности Фибоначчи}
	
	Ассемблерный код функции для подсчета значений последовательности Фибоначчи представлен на листинге ниже.
	
	{\small \VerbatimInput{../program/01_fibonacci/main.S}}
	
	Моделирование программы проводилось в среде Icarus Verilog.
	
	Ниже приведена часть логов из выполнения программы:
	
	{\small \VerbatimInput{./logs/01_fibonacci.txt}}
	
	Вейвформа при моделировании программы (рис. \ref{fig:01wvf}).
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.95\linewidth]{images/01_wvf}
		\caption{Вейвформа для последовательности Фибоначчи}
		\label{fig:01wvf}
	\end{figure}

	В регистре v0 помещается текущее значение последовательности Фиббоначи.
	

	\subsection{Моделирование извлечения квадратного корня}
	
	Ассемблерный код функции для вычисления квадратного корня представлен на листинге ниже.
	
	{\small \VerbatimInput{../program/02_sqrt/main.S}}
	
	Моделирование программы проводилось в среде Icarus Verilog.
	
	Лог выполнения программы:
	
	{\small \VerbatimInput{./logs/02_sqrt.txt}}
	
	Вейвформа при моделировании программы (рис. \ref{fig:02wvf}).
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.95\linewidth]{images/02_wvf}
		\caption{Вейвформа для программы извлечения квадратного корня}
		\label{fig:02wvf}
	\end{figure}

	Результат вычисления программы помещается регистр v0.
	
	
	\section{Самостоятельная работа}
	
	\subsection{Добавление новых команд}
	
	В соответствии с заданием необходимо добавить команды: j, xori, sllv, nor.
	
	Команда безусловного перехода j записывает новое значение в счётчик команд \cite{Harris}.
	Для реализации данной команды необходимо добавить новый выход у Control unit, который будет отвечать за безусловный переход.
	В случае установки данного флага будет изменено значение счетчика команд (PC).
	Адрес перехода получается из второй части команды j.
	
	Для реализации остальных команд необходимо расширить возможности ALU: добавить операции xor, sll, nor.
	После этого добавляются строки в мультиплексор, которые отвечают за распознавание команд.
	Команда xori является операцией I-типа и работает с константой, остальные операции R-типа и работают с регистрами.
	
	Для тестирования кода была написана небольшая программа на ассемблере:
		
	{\small \VerbatimInput{../program/98_commands_visualization/main.S}}
	
	Моделирование программы проводилось в среде Icarus Verilog.
	
	Лог выполнения программы:
	
	{\small \VerbatimInput{./logs/98_commands_visualization.txt}}
	
	\subsection{Разработка программы нахождения суммы геометрической прогрессии}
	
	Ассемблерный код функции для вычисления суммы геометрической прогрессии представлен на листинге ниже.
	
	{\small \VerbatimInput{../program/99_geometric_progression/main.S}}
	
	После метки start происходит инициализация значений в соответствии с вариантом.
	Далее выполняются команды внутри метки for\_loop, где на каждом цикле вычисляется новое значение геометрической прогрессии.
	Умножение реализовано в виде функции в метке multiplyer.
	Когда вычисленно нужное число членов геометрической прогрессии, цикл for\_loop завершается и выполняется код под меткой end.
	В метке end вычисленная сумма перемещается в регистр v0.
	
	Моделирование программы проводилось в среде Icarus Verilog.
	
	Лог выполнения программы:
	
	{\small \VerbatimInput{./logs/99_geometric_progression.txt}}
	
	Вейвформа при моделировании программы (рис. \ref{fig:99wvf}).
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.95\linewidth]{images/99_wvf}
		\caption{Вейвформа для суммы геометрической прогрессии}
		\label{fig:99wvf}
	\end{figure}

	Результаты из программы Mars совпадают c результатами из моделирования (рис. \ref{fig:99mars}).

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\linewidth]{images/99_mars}
		\caption{Результаты моделирования в программе Mars}
		\label{fig:99mars}
	\end{figure}

	\subsection{Моделирование программ на процессоре из ветки 01\_mmio}
	
	Было произведено моделирование программ  00\_counter, 01\_fibonacci, 02\_sqrt, все по-прежнему работают, но никаких изменений в логах или вейвформах нет.
	
	В соответствии с вариантом была смоделирована программа 04\_gpio. Ее ассемблерный код:
	
	{\small \VerbatimInput{../program/04_gpio/main.S}}
	
	В метке init происходит обнуление регистра t0 и запись в регистр t1 длительности задержки.
	Далее в метке delay циклически увеличивается регистр t0, пока он не станет равен t1.
	После этого регистр t0 обнуляется.
	Под меткой read происходит чтение данных из памяти для GPIO.
	Под меткой write происходит запись данных в память для GPIO.
	далее возвращаемся к метке delay.
	
	Ниже приведена часть логов из выполнения программы:
	
	{\small \VerbatimInput{./logs/04_gpio_logs.txt}}
	
	Вейвформа при моделировании программы (рис. \ref{fig:04wvf}).
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.95\linewidth]{images/04_wvf}
		\caption{Вейвформа для GPIO}
		\label{fig:04wvf}
	\end{figure}
	
	
	
	\section{Выводы по работе}
	
	В ходе работы получен опыт проектирования схем в программе Quartus с помощью языка Verilog.
	Полученное устройство было протестировано с помощью бенчтестов в программе Quartus Simulation Waveform editor.
	В процессе работы были смоделированы устройства для конвейерной обработки данных и изучены различные способы моделирования.
	В процессе был получен опыт работы с платой DE10-Lite, на которой проверялась работоспособность полученного устройства.
	
	\newpage 
	\renewcommand{\refname}{{\normalsize Список использованных источников}} 
	\centering 
	\begin{thebibliography}{9} 
		\addcontentsline{toc}{section}{\refname} 
		\bibitem{Harris} Хэррис Д. М., Хэррис С. Л. Цифровая схемотехника и архитектура компьютера. – 2015.
	\end{thebibliography}
	
\end{document} % конец документа
